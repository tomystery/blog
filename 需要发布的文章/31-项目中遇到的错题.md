1. antd与封装好的基础库的antd冲突了，在package.json文件中加入下面的就可以了
  ```js
   "resolutions": {
    "@rider-data/rider-component/antd": "^4.15.5"
  }
  ```
2. codeMirror2与antd的Modal在第二次点击的时候会发现回填的样式出现错误，主要是由于codeMirror2本身的代码相关的问题,modal使用的时候加上`destroyOnClose`就好，具体的代码可以看下面[codemirror2代码]()

3. http1.1 pending的请求最多是多个，单是处于链接状态的最多6个
  * 我用 koa 搭了个 api，这个 api 会等待 5s 在返回，然后我在客户用 Promise.all 同时发起了 20 个请求
  * 结果现实同时只会有 6 个连接生效，其他请求都是在等待的状态
  * 我刚想到用 http2 是不是会不一样，测试了下，果然 http2 可以同时连接 20 个请求。
后面我提高数量测试了下，http2 同时连接的上限应该是在 100 。
只是暂时还不确定是 http2 的限制，当时 chrome 的限制
  * [stackoverflow上回答](https://stackoverflow.com/questions/62477498/how-to-get-around-browsers-6-concurrent-connections-per-domain-limit)
  ![](./img/http1.1.png)

4. 某天在react项目的全局中使用了一个this.graph，刚开始是空对象，后面通过异步获取到this.graph之后由于他不是存在store中，那么就调用this.render(),发现在
  ```js
  render(){
    console.log(this.graph,Object.keys(this.graph)) //这里的this.graph，以及Object.keys的内容发生了变化，但是你在return的页面中显示的时候还是没有发生变化
    return(
      <div>{Object.keys(this.graph)}</div>//这里并没有发生变化，数量还是0
    )
  }
  ```

  React 是一个框架，他会有自己的一些规则在里面，只有按照他的规则来，才能得到想要的结果。（当然，如果你足够了解底层，知道这么操作的可以的获得想要的结果，那也可以）
  如果你知道手动去调用 render 能获得你想要的结果，那就可以这么去操作。而如果你不知道这么操作的结果，那就最好不要这么做

  说回你这代码，像你这样不按照生命周期来，那就很容易出现意外。这就是 bug，平常开发就都很累的，就没必要给自己增加负担了。
5. try,catch,finally的问题,问你最后返回的是那个？[js执行语句理解方式](https://blog.csdn.net/liuhua_2323/article/details/102893840)
  ```js
  try(){
    return 1
  }catch{
    return 2
  }
  finally{
    return 3
  }
  ```
  之前讨论过关于在 finally 语句中 return 的问题，当时我是根据规范中的说明去解释这个现象的。
  今天发现可以从 JS 语句执行机制这个角度去理解这个现象。
  这个角度比规范上单调的文字说明更容易理解，同时也能加深对 JS 执行过程的理解。
  具体可以看看下面这篇文章

  